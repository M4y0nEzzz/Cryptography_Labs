# Лабораторная работа №1

## 1. Алгоритмы и схемы

Начнем с небольшого блока теории.

### Потоковый XOR с XorShift32
- **Потоковый шифр** - это симметричный шифр, где каждый бит/байт открытого текста объединяется операцией XOR с 
соответствующим битом/байтом ключевого потока.
- **Формула шифрования** : `ciphertext[i] = plaintext[i] ⊕ keystream[i]`
- **Дешифрование идентично**: `plaintext[i] = ciphertext[i] ⊕ keystream[i]`
- **XorShift** - семейство быстрых генераторов псевдослучайных чисел, предложенных Джорджем Марсальей. 
XorShift32 использует 32-битное состояние и три операции сдвига-XOR.

```txt
class XorShift32:

    __slots__ = ("state",)

    def __init__(self, state: int) -> None:
        if state == 0:
            state = 0x12345678
        self.state = state & 0xFFFFFFFF

    def next_u32(self) -> int:
        x = self.state
        x ^= (x << 13) & 0xFFFFFFFF
        x ^= (x >> 17) & 0xFFFFFFFF
        x ^= (x << 5) & 0xFFFFFFFF
        self.state = x & 0xFFFFFFFF
        return self.state

    def next_byte(self) -> int:
        return self.next_u32() & 0xFF
```

- **Состояние генератора** обновляется по формуле:
```txt
    x ^= (x << 13) & 0xFFFFFFFF
    x ^= (x >> 17) & 0xFFFFFFFF
    x ^= (x << 5) & 0xFFFFFFFF
```
Она обеспечивает полный период 2³²-1.

- **Инициализация генератора** происходит по следующему принципу:
```txt
def _derive_stream_seed(key: bytes, iv: bytes) -> int:
    h = _sha256(key + iv)
    seed = int.from_bytes(h[:4], "big")
    if seed == 0:
        seed = 0x87654321
    return seed
```

- **Генерация ключевого потока**:
```txt
def _keystream_xorshift(key: bytes, iv: bytes, n_bytes: int) -> bytes:
    seed = _derive_stream_seed(key, iv)
    prng = XorShift32(seed)
    return bytes(prng.next_byte() for _ in range(n_bytes))
```

- **Преимущества**: высокая скорость, небольшой код, равномерное распределение.

- **Недостатки**: предсказуемость, не стойкий, уязвимый к атакам.




### AES в режимах ECB, CBC и CTR.

#### ECB (Electronic Codebook)
- **Сам режим ECB** - наиболее простой режим блочного шифрования, в котором каждый блок открытого текста шифруется 
независимо с использованием одного и того же ключа, причем если блоки открытого текста одинаковые, то и
шифротексты будут одинаковыми.
- **Паддинг**: не используется, но требуется, чтобы данные были кратны 16 байтам.
- **Размер блока**: 16 байт.
- **Характеристики**: простота реализации, плиточный эффект.



### CBC (Cipher Block Changing)
- **Особенности**: каждый блок XOR'ится с предыдущим зашифрованным блоком. Первый блок XOR'ится с IV.
- **Паддинг**: не используется, но требуется, чтобы данные были кратны 16 байтам.
- **Размер блока**: 16 байт.
- **IV**: 16 байт.
- **Характеристики**: последовательная обработка блоков, обязательная генерация нового 
уникального IV для каждого блока.


### CTR (Counter)
- **Особенности**: режим потока, использует счетчик для генерации ключевого потока и nonce.
- **Паддинг**: не требуется.
- **Nonce**: 8 байт.
- **Счетчик**: 8 байт.
- **Характеристики**: поточный характер, не требует паддинга.




## 2. Формирование и хранение IV/nonce

- **XOR**: IV длиной 16 байт генерируется случайно для каждого шифрования. Сохраняется в метаданных.
- **AES-CBC**: IV длиной 16 байт генерируется случайно для каждого шифрования. Сохраняется в метаданных.
- **AES-CTR**: nonce длиной 8 байт генерируется случайно для каждого шифрования. Сохраняется в метаданных.
- **Генерация** осуществляется функцией os.random(8/16).

IV/nonce никогда не повторяются для одного ключа. Они сохраняются в файлах с метаданными в hex-формате.

## 3. Метрики и гистрограммы
- **Энтропия Шеннона** (исходное и зашифрованное изображение). 
Измеряет степень случайности в данных. Для изображения она показывает, насколько значение следующего
пикселя сложно предсказать. 
Формула:
```txt
H(X) = -Σ p(x) × log₂(p(x))
```
Здесь p(x) - вероятность появления значения х в данных.

- Корреляция соседних пикселей по горизонтали (исходное и зашифрованное).
Показывает, насколько сильно различаются соседние пиксели.

- NPCR (Number of Pixels Change Rate) и UACI (Unified Average Changing Intensity) между исходным и зашифрованным изображением.
Измеряются сила изменения значений пикселей между двумя изображениями и средняя интенсивность изменений соответственно.

- Чувствительность к ключу: NPCR и UACI между шифрами, полученными с исходным ключом и ключом с измененным одним битом.


Рассмотрим несколько примеров гистограмм и метрик, которые у меня получились: 

1) Шахматная доска, алгоритм aes-ecb.
2) Градиент, алгоритм aes-cbc.
3) Майнкрафт, алгоритм aes-ctr.
4) Пустота, алгоритм xor.


## 4. Проверка обратимости

Для каждого алгоритма мы проверяем, что дешифрование восстанавливает исходное изображение побитово.
Мы вычисляем хэш SHA256 исходного изображения, а побитовое сравнение выполняется после каждого выполнения 
алгоритма функцией `assert`.
